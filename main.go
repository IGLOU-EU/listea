// Copyright 2020 Iglou.eu
// license that can be found in the LICENSE file

package main

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"

	"github.com/getlantern/systray"
	"github.com/getlantern/systray/example/icon"
)

// AutoGenerated struct from standard v1 Gitea API
type AutoGenerated []struct {
	ID      int    `json:"id"`
	URL     string `json:"url"`
	HTMLURL string `json:"html_url"`
	Number  int    `json:"number"`
	User    struct {
		ID        int       `json:"id"`
		Login     string    `json:"login"`
		FullName  string    `json:"full_name"`
		Email     string    `json:"email"`
		AvatarURL string    `json:"avatar_url"`
		Language  string    `json:"language"`
		IsAdmin   bool      `json:"is_admin"`
		LastLogin time.Time `json:"last_login"`
		Created   time.Time `json:"created"`
		Username  string    `json:"username"`
	} `json:"user"`
	OriginalAuthor   string `json:"original_author"`
	OriginalAuthorID int    `json:"original_author_id"`
	Title            string `json:"title"`
	Body             string `json:"body"`
	Labels           []struct {
		ID          int    `json:"id"`
		Name        string `json:"name"`
		Color       string `json:"color"`
		Description string `json:"description"`
		URL         string `json:"url"`
	} `json:"labels"`
	Milestone   interface{} `json:"milestone"`
	Assignee    interface{} `json:"assignee"`
	Assignees   interface{} `json:"assignees"`
	State       string      `json:"state"`
	IsLocked    bool        `json:"is_locked"`
	Comments    int         `json:"comments"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	ClosedAt    interface{} `json:"closed_at"`
	DueDate     interface{} `json:"due_date"`
	PullRequest interface{} `json:"pull_request"`
	Repository  struct {
		ID       int    `json:"id"`
		Name     string `json:"name"`
		Owner    string `json:"owner"`
		FullName string `json:"full_name"`
	} `json:"repository"`
}

// APIResultList inline type def
type APIResultList struct {
	entry []APIResult
}

// APIResult inline type def
type APIResult struct {
	ID          int
	Title       string
	Comments    int
	Repository  string
	HTMLURL     string
	LabelsName  string
	LabelsColor string
}

// Config inline type def
type Config struct {
	APIURL   string `json:"api_url"`
	APIToken string `json:"api_token"`
	List     []List `json:"list"`
}

// QueryKey inline type def
type QueryKey struct {
	Q          string `json:"q"`
	Type       string `json:"type"`
	State      string `json:"state"`
	Labels     string `json:"labels"`
	Milestones string `json:"milestones"`
}

// List inline type def
type List struct {
	APIRequest string   `json:"api_request"`
	QueryKey   QueryKey `json:"query_key"`
}

// APIRequest inline type def
type APIRequest struct {
	URL  []string
	Hash []string
}

var apiRequest APIRequest
var menuItemList []systray.MenuItem

func init() {
	cf, err := ioutil.ReadFile("config")
	if err != nil {
		log.Fatal(err)
	}

	var config Config
	err = json.Unmarshal(cf, &config)
	if err != nil {
		log.Fatal(err)
	}

	apiRequest.URL = buildAPIRequest(config)
	apiRequest.Hash = make([]string, len(apiRequest.URL))

	go systray.Run(onReady, nil)
}

func main() {

	for {
		apiResult := make([]APIResultList, len(apiRequest.URL))

		proceedAPIRequest(apiResult[:])
		renderAPISystray(apiResult)

		fmt.Println(apiResult)
		time.Sleep(1 * time.Minute)
	}
}

func onReady() {
	systray.SetIcon(icon.Data)
	systray.SetTitle("Listea")
	systray.SetTooltip("Task list viewer with a cup of tea")
}

func renderAPISystray(d []APIResultList) {
	if len(d) < 1 {
		return
	}

	for _, v := range d {
		if len(v.entry) < 1 {
			return
		}

		menuItemAPI(v.entry)
	}
}

func menuItemAPI(d []APIResult) {
	t := systray.AddMenuItem(fmt.Sprintf("ðŸ“‹ %s", d[0].Repository), "")
	t.Disable()
	systray.AddSeparator()

	for _, v := range d {
		systray.AddMenuItem(fmt.Sprintf("(%s) {%b} %s", v.LabelsName, v.Comments, v.Title), "firefox")

	}
}

func proceedAPIRequest(o []APIResultList) {
	for i, v := range apiRequest.URL {
		get, err := http.Get(v)
		if err != nil {
			log.Println("Unable to get on : " + v)
			log.Println(err)
			continue
		}
		defer get.Body.Close()

		body, err := ioutil.ReadAll(get.Body)
		if err != nil {
			log.Println("Unable read body : " + v)
			log.Println(err)
			continue
		}

		_ = body

		h := sha256.New()
		h.Write([]byte(body))
		hsum := fmt.Sprintf("%x", h.Sum(nil))

		if apiRequest.Hash[i] != hsum {
			o[i] = proceedAPIResult(body)
			apiRequest.Hash[i] = hsum
		}
	}
}

func proceedAPIResult(body []byte) APIResultList {
	var res APIResultList

	var api AutoGenerated
	err := json.Unmarshal(body, &api)
	if err != nil {
		log.Fatal(err)
	}

	for _, v := range api {
		var data APIResult

		data.ID = v.ID
		data.Title = v.Title
		data.Comments = v.Comments
		data.Repository = v.Repository.FullName
		data.HTMLURL = v.HTMLURL

		if len(v.Labels) > 0 {
			data.LabelsName = v.Labels[0].Name
			data.LabelsColor = v.Labels[0].Color
		}

		res.entry = append(res.entry, data)
	}

	return res
}

func buildAPIRequest(config Config) []string {
	var list []string

	for _, v := range config.List {
		list = append(list,
			fmt.Sprintf(
				"%s%s?%stoken=%s",
				config.APIURL,
				v.APIRequest,
				buildAPIQuery(v.QueryKey),
				config.APIToken,
			),
		)
	}

	return list
}

func buildAPIQuery(query QueryKey) string {
	o := ""

	if !empty(query.Q) {
		o += fmt.Sprintf("q=%s&", query.Q)
	}

	if !empty(query.Type) {
		o += fmt.Sprintf("type=%s&", query.Type)
	}

	if !empty(query.State) {
		o += fmt.Sprintf("state=%s&", query.State)
	}

	if !empty(query.Labels) {
		o += fmt.Sprintf("labels=%s&", query.Labels)
	}

	if !empty(query.Milestones) {
		o += fmt.Sprintf("milestones=%s&", query.Milestones)
	}

	return o
}

func empty(v string) bool {
	if v != "" {
		return true
	}

	return false
}
