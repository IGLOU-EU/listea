// Copyright 2020 Iglou.eu
// license that can be found in the LICENSE file

package main

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

// AutoGenerated struct from standard v1 Gitea API
type AutoGenerated []struct {
	ID      int    `json:"id"`
	URL     string `json:"url"`
	HTMLURL string `json:"html_url"`
	Number  int    `json:"number"`
	User    struct {
		ID        int       `json:"id"`
		Login     string    `json:"login"`
		FullName  string    `json:"full_name"`
		Email     string    `json:"email"`
		AvatarURL string    `json:"avatar_url"`
		Language  string    `json:"language"`
		IsAdmin   bool      `json:"is_admin"`
		LastLogin time.Time `json:"last_login"`
		Created   time.Time `json:"created"`
		Username  string    `json:"username"`
	} `json:"user"`
	OriginalAuthor   string `json:"original_author"`
	OriginalAuthorID int    `json:"original_author_id"`
	Title            string `json:"title"`
	Body             string `json:"body"`
	Labels           []struct {
		ID          int    `json:"id"`
		Name        string `json:"name"`
		Color       string `json:"color"`
		Description string `json:"description"`
		URL         string `json:"url"`
	} `json:"labels"`
	Milestone   interface{} `json:"milestone"`
	Assignee    interface{} `json:"assignee"`
	Assignees   interface{} `json:"assignees"`
	State       string      `json:"state"`
	IsLocked    bool        `json:"is_locked"`
	Comments    int         `json:"comments"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	ClosedAt    interface{} `json:"closed_at"`
	DueDate     interface{} `json:"due_date"`
	PullRequest interface{} `json:"pull_request"`
	Repository  struct {
		ID       int    `json:"id"`
		Name     string `json:"name"`
		Owner    string `json:"owner"`
		FullName string `json:"full_name"`
	} `json:"repository"`
}

// Config inline type def
type Config struct {
	APIURL   string `json:"api_url"`
	APIToken string `json:"api_token"`
	List     []List `json:"list"`
}

// QueryKey inline type def
type QueryKey struct {
	Q          string `json:"q"`
	Type       string `json:"type"`
	State      string `json:"state"`
	Labels     string `json:"labels"`
	Milestones string `json:"milestones"`
}

// List inline type def
type List struct {
	APIRequest string   `json:"api_request"`
	QueryKey   QueryKey `json:"query_key"`
}

// APIRequest inline type def
type APIRequest struct {
	URL  []string
	Hash []string
}

var apiRequest APIRequest

func init() {
	cf, err := ioutil.ReadFile("config")
	if err != nil {
		log.Fatal(err)
	}

	var config Config
	err = json.Unmarshal(cf, &config)
	if err != nil {
		log.Fatal(err)
	}

	apiRequest.URL = buildAPIRequest(config)
	apiRequest.Hash = make([]string, len(apiRequest.URL))
}

func main() {

	for {
		proceedAPIRequest()
		fmt.Println(apiRequest)
		time.Sleep(30 * time.Minute)
	}
}

func proceedAPIRequest() {
	for i, v := range apiRequest.URL {
		get, err := http.Get(v)
		if err != nil {
			log.Println("Unable to get on : " + v)
			log.Println(err)
			continue
		}
		defer get.Body.Close()

		body, err := ioutil.ReadAll(get.Body)
		if err != nil {
			log.Println("Unable read body : " + v)
			log.Println(err)
			continue
		}

		_ = body

		h := sha256.New()
		h.Write([]byte(body))
		hsum := fmt.Sprintf("%x", h.Sum(nil))

		if apiRequest.Hash[i] != hsum {
			apiRequest.Hash[i] = hsum
		}
	}
}

func buildAPIRequest(config Config) []string {
	var list []string

	for _, v := range config.List {
		list = append(list,
			fmt.Sprintf(
				"%s%s?%stoken=%%20%%20%s",
				config.APIURL,
				v.APIRequest,
				buildAPIQuery(v.QueryKey),
				config.APIToken,
			),
		)
	}

	return list
}

func buildAPIQuery(query QueryKey) string {
	o := ""

	if !empty(query.Q) {
		o += fmt.Sprintf("q=%s&", query.Q)
	}

	if !empty(query.Type) {
		o += fmt.Sprintf("type=%s&", query.Type)
	}

	if !empty(query.State) {
		o += fmt.Sprintf("state=%s&", query.State)
	}

	if !empty(query.Labels) {
		o += fmt.Sprintf("labels=%s&", query.Labels)
	}

	if !empty(query.Milestones) {
		o += fmt.Sprintf("milestones=%s&", query.Milestones)
	}

	return o
}

func empty(v string) bool {
	if v != "" {
		return true
	}

	return false
}
